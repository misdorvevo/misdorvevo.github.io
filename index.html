<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Will Hatch - Desktop</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <!-- Desktop Environment -->
    <div class="desktop">
        <!-- Desktop Icons -->
        <div class="desktop-icons">
            <div class="desktop-icon" data-file="About.txt">
                <div class="icon-image">üìÑ</div>
                <div class="icon-label">About.txt</div>
            </div>
            <div class="desktop-icon" data-file="Purpose.txt">
                <div class="icon-image">üí≠</div>
                <div class="icon-label">Purpose.txt</div>
            </div>
            <div class="desktop-icon" data-file="Links.url">
                <div class="icon-image">üîó</div>
                <div class="icon-label">Links.url</div>
            </div>
            <div class="desktop-icon" data-file="Projects">
                <div class="icon-image">üìÅ</div>
                <div class="icon-label">Projects</div>
            </div>
            <div class="desktop-icon" data-file="MineSweeper.exe">
                <div class="icon-image">üí£</div>
                <div class="icon-label">MineSweeper.exe</div>
            </div>
        </div>

        <!-- Windows Container -->
        <div class="windows-container" id="windows-container"></div>

        <!-- Taskbar -->
        <div class="taskbar">
            <div class="taskbar-start">
                <button class="start-button" id="start-button">Start</button>
            </div>
            <div class="taskbar-windows" id="taskbar-windows"></div>
            <div class="taskbar-tray">
                <span class="system-time" id="system-time">12:00</span>
            </div>
        </div>
    </div>

    <script>
        // ============= FILE SYSTEM SIMULATOR =============
        const fileSystem = {
            files: {
                'About.txt': {
                    type: 'text',
                    content: `Will Hatch - About Me
=====================================

Will Hatch is a junior at Berklee College of Music, specializing in hip-hop and electronic music production. 

Currently active as:
‚Ä¢ vvill - Solo music producer
‚Ä¢ Connxtion - Group producer and collaborator

Known for experimental production techniques and a commitment to the creative process. Always exploring new sounds and pushing boundaries in electronic music.

Based in Boston, MA
Berklee College of Music
Class of 2026`
                },
                'Purpose.txt': {
                    type: 'text',
                    content: `Purpose Statement
=====================================

This project is meant to solve a small but annoying step in the release process for independent artists.

Using a custom tool, artists will be able to create a detailed release plan for their upcoming music releases.

The Problem:
As an independent artist, organization of release timelines, marketing plans, and distribution strategies can be overwhelming. Many tools exist but often overcomplicate the process or don't align with artistic workflow.

The Solution:
A flexible, artist-friendly release planning tool that:
‚Ä¢ Doesn't step on your creative toes
‚Ä¢ Adapts to YOUR goals as an artist
‚Ä¢ Simplifies the release process
‚Ä¢ Takes the stress out of planning

This tool will help artists focus on making great music while staying organized.`
                },
                'Links.url': {
                    type: 'url',
                    content: `Important Links
=====================================

Music Platforms:
‚Ä¢ Apple Music - Listen to vvill & Connxtion tracks
‚Ä¢ Spotify - Follow and discover new releases
‚Ä¢ Bandcamp - Support directly

Social Media:
‚Ä¢ Instagram - @vvill (vvill)
‚Ä¢ Instagram - @connxtion (Connxtion)

Contact:
‚Ä¢ Email: willhatch@berklee.edu
‚Ä¢ Location: Boston, MA

Berklee College of Music
Founded 1945 | Boston, Massachusetts`
                }
            },
            folders: {
                'Projects': {
                    files: {
                        'Release-Planner.txt': {
                            type: 'text',
                            content: `Release Planner Tool
=====================================

Status: In Development

This is the primary project - a comprehensive release planning tool for independent artists.

Features:
‚Ä¢ Timeline visualization
‚Ä¢ Marketing checklist
‚Ä¢ Distribution management
‚Ä¢ Collaborative planning
‚Ä¢ Analytics dashboard

Target Launch: 2026`
                        },
                        'Connxtion-Info.txt': {
                            type: 'text',
                            content: `Connxtion
=====================================

A collaborative music production group focused on creating innovative hip-hop and electronic music.

Members:
‚Ä¢ Will Hatch (Producer)
‚Ä¢ [Other collaborators]

Notable Projects:
‚Ä¢ Multiple collaborative releases
‚Ä¢ Experimental production sessions
‚Ä¢ Community-driven music initiatives

Philosophy:
Pushing creative boundaries while maintaining artistic integrity and collaboration at the core.`
                        }
                    }
                }
            }
        };

        // ============= WINDOW MANAGER =============
        class WindowManager {
            constructor() {
                this.windows = [];
                this.zIndex = 1000;
                this.container = document.getElementById('windows-container');
                this.taskbarWindows = document.getElementById('taskbar-windows');
            }

            openFile(filename, fromFolder = null) {
                // Check if window already open
                const existingWindow = this.windows.find(w => w.filename === filename && w.folder === fromFolder);
                if (existingWindow) {
                    existingWindow.element.style.zIndex = ++this.zIndex;
                    existingWindow.element.classList.remove('minimized');
                    return;
                }

                let fileData;
                if (fromFolder) {
                    fileData = fileSystem.folders[fromFolder].files[filename];
                } else {
                    fileData = fileSystem.files[filename];
                }

                if (!fileData) return;

                const windowElement = this.createWindowElement(filename, fileData, fromFolder);
                this.container.appendChild(windowElement);

                const windowObj = {
                    filename,
                    folder: fromFolder,
                    element: windowElement,
                    content: fileData.content
                };

                this.windows.push(windowObj);
                this.addTaskbarButton(filename, windowObj);
                this.makeWindowDraggable(windowElement);
                windowElement.style.zIndex = ++this.zIndex;
            }

            openFolder(folderName) {
                const existingWindow = this.windows.find(w => w.folder === folderName && w.filename === folderName);
                if (existingWindow) {
                    existingWindow.element.style.zIndex = ++this.zIndex;
                    existingWindow.element.classList.remove('minimized');
                    return;
                }

                const folder = fileSystem.folders[folderName];
                if (!folder) return;

                const windowElement = this.createFolderWindow(folderName, folder);
                this.container.appendChild(windowElement);

                const windowObj = {
                    filename: folderName,
                    folder: folderName,
                    element: windowElement
                };

                this.windows.push(windowObj);
                this.addTaskbarButton(folderName, windowObj);
                this.makeWindowDraggable(windowElement);
                windowElement.style.zIndex = ++this.zIndex;
            }

            createWindowElement(filename, fileData, fromFolder) {
                const isUrl = fileData.type === 'url';
                const windowId = `window-${this.windows.length}`;
                
                const window = document.createElement('div');
                window.className = 'window';
                window.id = windowId;
                window.style.left = (50 + Math.random() * 200) + 'px';
                window.style.top = (50 + Math.random() * 200) + 'px';

                window.innerHTML = `
                    <div class="window-titlebar">
                        <span class="window-title">${filename}</span>
                        <div class="window-buttons">
                            <button class="window-btn minimize-btn" data-window="${windowId}">_</button>
                            <button class="window-btn close-btn" data-window="${windowId}">√ó</button>
                        </div>
                    </div>
                    <div class="window-content">
                        <div class="file-viewer">
                            <pre>${this.escapeHtml(fileData.content)}</pre>
                        </div>
                    </div>
                `;

                window.querySelector('.minimize-btn').addEventListener('click', () => this.minimizeWindow(windowId));
                window.querySelector('.close-btn').addEventListener('click', () => this.closeWindow(windowId));

                return window;
            }

            createFolderWindow(folderName, folder) {
                const windowId = `window-${this.windows.length}`;
                
                const window = document.createElement('div');
                window.className = 'window';
                window.id = windowId;
                window.style.left = (50 + Math.random() * 200) + 'px';
                window.style.top = (50 + Math.random() * 200) + 'px';
                window.style.width = '400px';

                let filesHtml = '';
                for (const [filename, fileData] of Object.entries(folder.files)) {
                    const icon = fileData.type === 'text' ? 'üìÑ' : 'üîó';
                    filesHtml += `
                        <div class="folder-item" data-file="${filename}" data-folder="${folderName}">
                            <div class="folder-icon">${icon}</div>
                            <div class="folder-name">${filename}</div>
                        </div>
                    `;
                }

                window.innerHTML = `
                    <div class="window-titlebar">
                        <span class="window-title">${folderName}</span>
                        <div class="window-buttons">
                            <button class="window-btn minimize-btn" data-window="${windowId}">_</button>
                            <button class="window-btn close-btn" data-window="${windowId}">√ó</button>
                        </div>
                    </div>
                    <div class="window-content">
                        <div class="folder-viewer">
                            ${filesHtml}
                        </div>
                    </div>
                `;

                // Add click handlers for files in folder
                window.querySelectorAll('.folder-item').forEach(item => {
                    item.addEventListener('dblclick', () => {
                        const filename = item.dataset.file;
                        const folder = item.dataset.folder;
                        this.openFile(filename, folder);
                    });
                });

                window.querySelector('.minimize-btn').addEventListener('click', () => this.minimizeWindow(windowId));
                window.querySelector('.close-btn').addEventListener('click', () => this.closeWindow(windowId));

                return window;
            }

            makeWindowDraggable(windowElement) {
                const titlebar = windowElement.querySelector('.window-titlebar');
                let offsetX = 0;
                let offsetY = 0;
                let isDragging = false;

                titlebar.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    offsetX = e.clientX - windowElement.offsetLeft;
                    offsetY = e.clientY - windowElement.offsetTop;
                });

                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        windowElement.style.left = (e.clientX - offsetX) + 'px';
                        windowElement.style.top = (e.clientY - offsetY) + 'px';
                    }
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                windowElement.addEventListener('mousedown', () => {
                    windowElement.style.zIndex = ++this.zIndex;
                });
            }

            minimizeWindow(windowId) {
                const window = document.getElementById(windowId);
                window.classList.toggle('minimized');
            }

            closeWindow(windowId) {
                const window = document.getElementById(windowId);
                const windowObj = this.windows.find(w => w.element.id === windowId);
                
                if (windowObj) {
                    this.windows = this.windows.filter(w => w !== windowObj);
                }

                const taskbarBtn = document.querySelector(`[data-window-id="${windowId}"]`);
                if (taskbarBtn) taskbarBtn.remove();

                window.remove();
            }

            addTaskbarButton(filename, windowObj) {
                const btn = document.createElement('button');
                btn.className = 'taskbar-window-btn';
                btn.dataset.windowId = windowObj.element.id;
                btn.textContent = filename;
                
                btn.addEventListener('click', () => {
                    const isMinimized = windowObj.element.classList.contains('minimized');
                    if (isMinimized) {
                        windowObj.element.classList.remove('minimized');
                        windowObj.element.style.zIndex = ++this.zIndex;
                    } else {
                        windowObj.element.classList.add('minimized');
                    }
                });

                this.taskbarWindows.appendChild(btn);
            }

            escapeHtml(text) {
                const map = {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#039;'
                };
                return text.replace(/[&<>"']/g, m => map[m]);
            }
        }

        // ============= MINESWEEPER GAME =============
        class MineSweeper {
            constructor() {
                this.ROWS = 8;
                this.COLS = 10;
                this.MINES = 10;
                this.board = [];
                this.revealed = [];
                this.flagged = [];
                this.gameOver = false;
                this.startTime = null;
                this.timerInterval = null;
            }

            init() {
                this.board = Array(this.ROWS).fill(null).map(() => Array(this.COLS).fill(0));
                this.revealed = Array(this.ROWS).fill(null).map(() => Array(this.COLS).fill(false));
                this.flagged = Array(this.ROWS).fill(null).map(() => Array(this.COLS).fill(false));
                this.gameOver = false;
                this.startTime = null;
                
                // Place mines
                let minesPlaced = 0;
                while (minesPlaced < this.MINES) {
                    const r = Math.floor(Math.random() * this.ROWS);
                    const c = Math.floor(Math.random() * this.COLS);
                    if (this.board[r][c] !== 'M') {
                        this.board[r][c] = 'M';
                        minesPlaced++;
                    }
                }

                // Calculate numbers
                for (let r = 0; r < this.ROWS; r++) {
                    for (let c = 0; c < this.COLS; c++) {
                        if (this.board[r][c] !== 'M') {
                            let count = 0;
                            for (let dr = -1; dr <= 1; dr++) {
                                for (let dc = -1; dc <= 1; dc++) {
                                    const nr = r + dr, nc = c + dc;
                                    if (nr >= 0 && nr < this.ROWS && nc >= 0 && nc < this.COLS && this.board[nr][nc] === 'M') {
                                        count++;
                                    }
                                }
                            }
                            this.board[r][c] = count;
                        }
                    }
                }
            }

            revealCell(r, c) {
                if (this.gameOver || this.revealed[r][c] || this.flagged[r][c]) return;
                
                if (!this.startTime) {
                    this.startTime = Date.now();
                    this.startTimer();
                }

                if (this.board[r][c] === 'M') {
                    this.gameOver = true;
                    this.revealAllMines();
                    return;
                }

                this.revealed[r][c] = true;
                if (this.board[r][c] === 0) {
                    this.floodFill(r, c);
                }

                this.checkWin();
            }

            flagCell(r, c) {
                if (this.gameOver || this.revealed[r][c]) return;
                this.flagged[r][c] = !this.flagged[r][c];
            }

            floodFill(r, c) {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const nr = r + dr, nc = c + dc;
                        if (nr >= 0 && nr < this.ROWS && nc >= 0 && nc < this.COLS && !this.revealed[nr][nc]) {
                            this.revealed[nr][nc] = true;
                            if (this.board[nr][nc] === 0) {
                                this.floodFill(nr, nc);
                            }
                        }
                    }
                }
            }

            checkWin() {
                let revealedCount = 0;
                for (let r = 0; r < this.ROWS; r++) {
                    for (let c = 0; c < this.COLS; c++) {
                        if (this.revealed[r][c]) revealedCount++;
                    }
                }
                if (revealedCount === this.ROWS * this.COLS - this.MINES) {
                    this.gameOver = true;
                    clearInterval(this.timerInterval);
                }
            }

            revealAllMines() {
                for (let r = 0; r < this.ROWS; r++) {
                    for (let c = 0; c < this.COLS; c++) {
                        if (this.board[r][c] === 'M') {
                            this.revealed[r][c] = true;
                        }
                    }
                }
                clearInterval(this.timerInterval);
            }

            startTimer() {
                this.timerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                    const timerEl = document.getElementById('ms-timer');
                    if (timerEl) timerEl.textContent = elapsed;
                }, 100);
            }

            getMineCount() {
                return this.MINES - this.flagged.flat().filter(f => f).length;
            }

            render(boardEl) {
                boardEl.innerHTML = '';
                for (let r = 0; r < this.ROWS; r++) {
                    for (let c = 0; c < this.COLS; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'ms-cell';

                        if (this.revealed[r][c]) {
                            cell.classList.add('revealed');
                            if (this.board[r][c] === 'M') {
                                cell.textContent = 'üí£';
                            } else if (this.board[r][c] > 0) {
                                cell.textContent = this.board[r][c];
                                cell.style.color = this.getNumberColor(this.board[r][c]);
                            }
                        } else if (this.flagged[r][c]) {
                            cell.classList.add('flagged');
                            cell.textContent = 'üö©';
                        }

                        cell.addEventListener('click', () => this.revealCell(r, c));
                        cell.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            this.flagCell(r, c);
                            this.render(boardEl);
                            this.updateGameInfo();
                        });

                        boardEl.appendChild(cell);
                    }
                }
                this.updateGameInfo();
            }

            updateGameInfo() {
                const counterEl = document.getElementById('ms-counter');
                if (counterEl) counterEl.textContent = this.getMineCount();
            }

            getNumberColor(num) {
                const colors = ['', '#0000ff', '#008000', '#ff0000', '#000080', '#800000', '#008080', '#808080', '#c0c0c0'];
                return colors[num] || '#000000';
            }
        }

        // ============= INITIALIZATION =============
        const windowManager = new WindowManager();
        let minesweeperGame = null;

        // Desktop icon click handlers
        document.querySelectorAll('.desktop-icon').forEach(icon => {
            icon.addEventListener('dblclick', () => {
                const file = icon.dataset.file;
                if (file === 'MineSweeper.exe') {
                    windowManager.openMineSweeper();
                } else if (fileSystem.folders[file]) {
                    windowManager.openFolder(file);
                } else {
                    windowManager.openFile(file);
                }
            });
        });

        // Add openMineSweeper method to WindowManager
        WindowManager.prototype.openMineSweeper = function() {
            const existingWindow = this.windows.find(w => w.filename === 'MineSweeper.exe');
            if (existingWindow) {
                existingWindow.element.style.zIndex = ++this.zIndex;
                existingWindow.element.classList.remove('minimized');
                return;
            }

            const windowId = `window-${this.windows.length}`;
            const window = document.createElement('div');
            window.className = 'window';
            window.id = windowId;
            window.style.left = (50 + Math.random() * 200) + 'px';
            window.style.top = (50 + Math.random() * 200) + 'px';
            window.style.width = '350px';

            window.innerHTML = `
                <div class="window-titlebar">
                    <span class="window-title">MineSweeper.exe</span>
                    <div class="window-buttons">
                        <button class="window-btn minimize-btn" data-window="${windowId}">_</button>
                        <button class="window-btn close-btn" data-window="${windowId}">√ó</button>
                    </div>
                </div>
                <div class="window-content">
                    <div class="minesweeper-game">
                        <div class="game-info">
                            <div class="game-counter">Mines: <span id="ms-counter">10</span></div>
                            <button id="ms-new-game-btn" class="game-button">New Game</button>
                            <div class="game-counter">Time: <span id="ms-timer">0</span>s</div>
                        </div>
                        <div id="ms-board" class="minesweeper-board"></div>
                    </div>
                </div>
            `;

            this.container.appendChild(window);

            const windowObj = {
                filename: 'MineSweeper.exe',
                folder: null,
                element: window
            };

            this.windows.push(windowObj);
            this.addTaskbarButton('MineSweeper.exe', windowObj);
            this.makeWindowDraggable(window);
            window.style.zIndex = ++this.zIndex;

            // Initialize game
            minesweeperGame = new MineSweeper();
            minesweeperGame.init();
            minesweeperGame.render(document.getElementById('ms-board'));

            document.getElementById('ms-new-game-btn').addEventListener('click', () => {
                minesweeperGame = new MineSweeper();
                minesweeperGame.init();
                minesweeperGame.render(document.getElementById('ms-board'));
            });

            window.querySelector('.minimize-btn').addEventListener('click', () => this.minimizeWindow(windowId));
            window.querySelector('.close-btn').addEventListener('click', () => this.closeWindow(windowId));
        };

        // Start button (can add start menu later)
        document.getElementById('start-button').addEventListener('click', () => {
            console.log('Start menu clicked');
        });

        // Update system time
        function updateTime() {
            const now = new Date();
            const time = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
            document.getElementById('system-time').textContent = time;
        }
        updateTime();
        setInterval(updateTime, 1000);
    </script>
</body>
</html>
